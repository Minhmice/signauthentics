"use client";

/**
 * Orders Management Page
 * Full CRUD operations với status management và bulk actions
 */

import * as React from "react";
import { DashboardSectionHeader } from "@/app/dashboard/components/shared/RoleBadge";
import { DataTable } from "@/app/dashboard/components/shared/DataTable";
import { ConfirmDialog } from "@/app/dashboard/components/shared/ConfirmDialog";
import {
  FilterPopover,
  FilterOption,
} from "@/app/dashboard/components/shared/FilterPopover";
import {
  ActionMenu,
  createActionItems,
} from "@/app/dashboard/components/shared/ActionMenu";
import { StatusBadge } from "@/app/dashboard/components/shared/StatusBadge";
import { OrderForm } from "./components/OrderForm";
import { Button } from "@/components/ui/button";
import { Plus, Trash2, Package, Eye, Edit } from "lucide-react";
import { ordersAPI, type Order } from "@/lib/mock/db";
import { formatPrice } from "@/lib/ui/price";
import { ClientDate } from "@/components/shared/ClientDate";
import { ColumnDef } from "@tanstack/react-table";
import { toast } from "sonner";

// Filter options for orders
const filterOptions: FilterOption[] = [
  {
    key: "paymentStatus",
    label: "Payment Status",
    type: "select",
    options: [
      { value: "paid", label: "Paid" },
      { value: "pending", label: "Pending" },
      { value: "unpaid", label: "Unpaid" },
      { value: "refunded", label: "Refunded" },
    ],
  },
  {
    key: "fulfillmentStatus",
    label: "Fulfillment Status",
    type: "select",
    options: [
      { value: "processing", label: "Processing" },
      { value: "shipped", label: "Shipped" },
      { value: "delivered", label: "Delivered" },
      { value: "cancelled", label: "Cancelled" },
    ],
  },
  {
    key: "paymentMethod",
    label: "Payment Method",
    type: "select",
    options: [
      { value: "bank_transfer", label: "Bank Transfer" },
      { value: "credit_card", label: "Credit Card" },
      { value: "momo", label: "MoMo" },
      { value: "zalopay", label: "ZaloPay" },
    ],
  },
  {
    key: "totalRange",
    label: "Total Range",
    type: "number",
    placeholder: "Min total",
  },
];

export default function DashboardOrdersPage() {
  const [mounted, setMounted] = React.useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = React.useState(false);
  const [isFormOpen, setIsFormOpen] = React.useState(false);
  const [orders, setOrders] = React.useState<Order[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [filters, setFilters] = React.useState<Record<string, unknown>>({});
  const [deleteOrderId, setDeleteOrderId] = React.useState<string | null>(null);
  const [selectedOrder, setSelectedOrder] = React.useState<Order | undefined>();

  // Mount effect
  React.useEffect(() => {
    setMounted(true);
  }, []);

  // Load orders
  React.useEffect(() => {
    loadOrders();
  }, [filters]);

  const loadOrders = async () => {
    try {
      setLoading(true);
      const data = await ordersAPI.getAll();
      setOrders(data.filter((order): order is Order => order !== null));
    } catch (error) {
      toast.error("Failed to load orders");
      console.error("Error loading orders:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleView = (order: Order) => {
    // TODO: Implement view order details
    toast.info("View order details");
  };

  const handleEdit = (order: Order) => {
    setSelectedOrder(order);
    setIsFormOpen(true);
  };

  const handleCreateNew = () => {
    setSelectedOrder(undefined);
    setIsFormOpen(true);
  };

  const handleSave = async (data: Record<string, unknown>) => {
    try {
      if (selectedOrder) {
        // Update existing order
        const updatedOrder = await ordersAPI.update(
          selectedOrder.id,
          data as Partial<Order>
        );
        if (updatedOrder) {
          setOrders(
            orders.map((o) => (o.id === selectedOrder.id ? updatedOrder : o))
          );
          toast.success("Order updated successfully");
        }
      } else {
        // Create new order
        const newOrder = await ordersAPI.create(
          data as Omit<Order, "id" | "createdAt" | "updatedAt">
        );
        setOrders([...orders, newOrder]);
        toast.success("Order created successfully");
      }
    } catch (error) {
      toast.error("Failed to save order");
      console.error("Error saving order:", error);
    } finally {
      setIsFormOpen(false);
      setSelectedOrder(undefined);
    }
  };

  const handleDelete = (order: Order) => {
    setDeleteOrderId(order.id);
    setIsDeleteDialogOpen(true);
  };

  const handleDuplicate = (order: Order) => {
    const duplicatedOrder = {
      ...order,
      id: "", // Will be generated by API
      orderNumber: `${order.orderId}-COPY`,
    };
    setSelectedOrder(duplicatedOrder);
    setIsFormOpen(true);
  };

  const confirmDelete = async () => {
    if (!deleteOrderId) return;

    try {
      await ordersAPI.delete(deleteOrderId);
      setOrders(orders.filter((o) => o.id !== deleteOrderId));
      toast.success("Order cancelled successfully");
    } catch (error) {
      toast.error("Failed to cancel order");
      console.error("Error cancelling order:", error);
    } finally {
      setIsDeleteDialogOpen(false);
      setDeleteOrderId(null);
    }
  };

  const handleBulkDelete = async (selectedIds: string[]) => {
    try {
      await ordersAPI.bulkDelete(selectedIds);
      setOrders(orders.filter((o) => !selectedIds.includes(o.id)));
      toast.success(`${selectedIds.length} orders cancelled successfully`);
    } catch (error) {
      toast.error("Failed to cancel orders");
      console.error("Error cancelling orders:", error);
    }
  };

  const handleStatusUpdate = async (
    orderId: string,
    status: string,
    type: "payment" | "fulfillment"
  ) => {
    try {
      const updates =
        type === "payment"
          ? { paymentStatus: status }
          : { fulfillmentStatus: status };

      const updatedOrder = await ordersAPI.update(orderId, updates);
      setOrders(
        orders
          .map((o) => (o.id === orderId ? updatedOrder : o))
          .filter(Boolean) as typeof orders
      );
      toast.success(`Order ${type} status updated to ${status}`);
    } catch (error) {
      toast.error(`Failed to update ${type} status`);
      console.error(`Error updating ${type} status:`, error);
    }
  };

  const handleExport = (format: string, data: Order[]) => {
    toast.success(`Exported ${data.length} orders as ${format.toUpperCase()}`);
  };

  const orderColumns: ColumnDef<Order>[] = [
    {
      accessorKey: "orderId",
      header: "Order ID",
      cell: ({ row }) => (
        <span className="font-mono text-xs">{row.original.orderId}</span>
      ),
    },
    {
      accessorKey: "buyerName",
      header: "Customer",
      cell: ({ row }) => (
        <div>
          <div className="font-medium">{row.original.buyerName}</div>
          <div className="text-xs text-zinc-500">{row.original.buyerEmail}</div>
        </div>
      ),
    },
    {
      accessorKey: "items",
      header: "Items",
      cell: ({ row }) => (
        <div className="text-sm">
          {row.original.items.length} item
          {row.original.items.length !== 1 ? "s" : ""}
        </div>
      ),
    },
    {
      accessorKey: "total",
      header: "Total",
      cell: ({ row }) => (
        <div className="text-right">
          <div className="font-semibold">
            {formatPrice(row.original.total, "VND")}
          </div>
          {row.original.discount > 0 && (
            <div className="text-xs text-green-500">
              -{formatPrice(row.original.discount, "VND")}
            </div>
          )}
        </div>
      ),
    },
    {
      accessorKey: "paymentStatus",
      header: "Payment",
      cell: ({ row }) => <StatusBadge status={row.original.paymentStatus} />,
    },
    {
      accessorKey: "fulfillmentStatus",
      header: "Fulfillment",
      cell: ({ row }) => (
        <StatusBadge status={row.original.fulfillmentStatus} />
      ),
    },
    {
      accessorKey: "createdAt",
      header: "Date",
      cell: ({ row }) => (
        <div className="text-sm">
          <ClientDate date={row.original.createdAt} variant="vn" />
        </div>
      ),
    },
    {
      id: "actions",
      header: "Actions",
      cell: ({ row }) => (
        <ActionMenu
          actions={createActionItems(
            () => handleEdit(row.original),
            () => handleDelete(row.original),
            () => handleView(row.original)
          )}
        />
      ),
    },
  ];

  const bulkActions = [
    {
      id: "bulk-cancel",
      label: "Cancel Selected",
      icon: <Trash2 className="w-4 h-4" />,
      variant: "destructive" as const,
      onClick: handleBulkDelete,
    },
  ];

  return (
    <div className="space-y-6">
      <DashboardSectionHeader
        title="Orders"
        description={`Quản lý đơn hàng - ${orders.length} orders total`}
        visibleFor={["admin", "seller"]}
        readOnlyFor={["editor"]}
        actions={
          <div className="flex items-center gap-2">
            <FilterPopover
              filters={filterOptions}
              values={filters}
              onValuesChange={setFilters}
              onClear={() => setFilters({})}
            />
            <Button
              onClick={handleCreateNew}
              className="bg-blue-600 hover:bg-blue-700 text-white"
            >
              <Plus className="w-4 h-4 mr-2" />
              Create Order
            </Button>
          </div>
        }
      />

      {/* Orders Table */}
      {mounted ? (
        <DataTable
          columns={orderColumns}
          data={orders}
          searchKey="orderId"
          searchPlaceholder="Search orders..."
          pageSize={10}
          loading={loading}
          getRowId={(row) => row.id}
          bulkActions={bulkActions}
          onExport={handleExport}
          onRowView={handleView}
          onRowEdit={handleEdit}
          onRowDelete={handleDelete}
          onRowDuplicate={handleDuplicate}
        />
      ) : (
        <div className="flex items-center justify-center h-32">
          <div className="text-sm text-gray-500">Loading...</div>
        </div>
      )}

      {/* Order Form Dialog */}
      <OrderForm 
        open={isFormOpen}
        onOpenChange={setIsFormOpen}
        order={selectedOrder}
        onSuccess={() => {
          loadOrders();
          setIsFormOpen(false);
        }}
      />

      {/* Delete Confirmation Dialog */}
      <ConfirmDialog
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
        title="Cancel Order"
        description="Are you sure you want to cancel this order? This action cannot be undone."
        confirmText="Cancel Order"
        onConfirm={confirmDelete}
        variant="destructive"
      />
    </div>
  );
}
